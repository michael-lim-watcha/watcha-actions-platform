name: reusable-ci-main

# NOTE(production): ECR ì „í™˜ ì‹œ ë³€ê²½ í•„ìš”:
#   - docker/login-action(ghcr) â†’ ecr-build-push composite action (extra-tag: latest)
#   - runner_label: ubuntu-latest â†’ arc-shared (self-hosted)
#   - cache-from/to: type=gha â†’ type=registry (ECR buildcache)
#   - helm-values-update step ì¶”ê°€ (prod CD trigger)

on:
  workflow_call:
    inputs:
      image_repository:
        description: Full image repository URI (e.g. ghcr.io/org/service)
        required: true
        type: string
      dockerfile:
        required: false
        type: string
        default: Dockerfile
      context:
        required: false
        type: string
        default: .
      back_merge_enabled:
        description: Create back-merge PR to develop when fix commits exist
        required: false
        type: boolean
        default: true
      initial_version:
        description: Version to use when no git tags exist
        required: false
        type: string
        default: v0.1.0
    secrets:
      GH_PAT:
        required: true

permissions:
  contents: write
  packages: write
  pull-requests: read

jobs:
  deploy-production:
    name: Docker Build (Production)
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.tag.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # fetch-tags: true ì˜µì…˜ì€ ì‹ ë¢°ì„± ë¬¸ì œ ìˆìŒ â†’ ëª…ì‹œì  fetch
      - name: Fetch all tags
        run: git fetch --tags --force

      - name: Resolve next version
        id: tag
        run: |
          latest=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
          if [ -z "$latest" ]; then
            next="${{ inputs.initial_version }}"
          else
            IFS='.' read -r major minor patch <<< "${latest#v}"
            next="v${major}.${minor}.$((patch + 1))"
          fi
          echo "version=${next}" >> "$GITHUB_OUTPUT"

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ inputs.image_repository }}
          tags: |
            type=raw,value=${{ steps.tag.outputs.version }}
            type=raw,value=latest

      - uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # TODO(production): helm-values-update (prod CD trigger)

      - name: Generate release notes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          prev_tag=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sed -n '2p')

          # prev_tag ~ HEAD ì‚¬ì´ ì»¤ë°‹ì—ì„œ PR ë²ˆí˜¸ ì¶”ì¶œ
          # merge commit:  "Merge pull request #N from ..."
          # squash commit: "PR title (#N)"
          if [ -n "$prev_tag" ]; then
            log_range="${prev_tag}..HEAD"
          else
            log_range="HEAD"
          fi

          pr_numbers=$(
            git log "$log_range" --pretty=format:"%s" \
              | grep -v "^chore: back-merge\|^release:" \
              | grep -oE '#[0-9]+' \
              | grep -oE '[0-9]+' \
              | sort -u
          )

          features="" fixes="" hotfixes="" maintenance=""
          refactoring="" docs="" reverts="" abtests="" others=""

          for pr_num in $pr_numbers; do
            pr_data=$(gh api "repos/${{ github.repository }}/pulls/${pr_num}" \
              --jq '{title: .title, ref: .head.ref}' 2>/dev/null) || continue
            title=$(echo "$pr_data" | jq -r '.title')
            ref=$(echo  "$pr_data" | jq -r '.ref')
            entry="- ${title} (#${pr_num})\n"

            case "$ref" in
              feature/*)  features="${features}${entry}"    ;;
              fix/*)      fixes="${fixes}${entry}"          ;;
              hotfix/*)   hotfixes="${hotfixes}${entry}"    ;;
              chore/*)    maintenance="${maintenance}${entry}" ;;
              refactor/*) refactoring="${refactoring}${entry}" ;;
              docs/*)     docs="${docs}${entry}"            ;;
              revert/*)   reverts="${reverts}${entry}"      ;;
              abtest/*)   abtests="${abtests}${entry}"      ;;
              *)          others="${others}${entry}"        ;;
            esac
          done

          {
            echo "## What's Changed"
            echo ""
            [ -n "$features"    ] && printf "### ğŸš€ Features\n%b\n"       "$features"
            [ -n "$fixes"       ] && printf "### ğŸ› Bug Fixes\n%b\n"      "$fixes"
            [ -n "$hotfixes"    ] && printf "### ğŸ”¥ Hotfixes\n%b\n"       "$hotfixes"
            [ -n "$maintenance" ] && printf "### ğŸ§¹ Maintenance\n%b\n"    "$maintenance"
            [ -n "$refactoring" ] && printf "### â™»ï¸ Refactoring\n%b\n"    "$refactoring"
            [ -n "$docs"        ] && printf "### ğŸ“ Docs\n%b\n"           "$docs"
            [ -n "$reverts"     ] && printf "### âª Reverts\n%b\n"        "$reverts"
            [ -n "$abtests"     ] && printf "### ğŸ§ª AB Tests\n%b\n"       "$abtests"
            [ -n "$others"      ] && printf "### ğŸ“¦ Other Changes\n%b\n"  "$others"
            [ -n "$prev_tag"    ] && echo "**Full Changelog**: ${{ github.server_url }}/${{ github.repository }}/compare/${prev_tag}...${{ steps.tag.outputs.version }}"
          } > /tmp/release_notes.md

          cat /tmp/release_notes.md

      - name: Create git tag and GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git tag ${{ steps.tag.outputs.version }}
          git push origin ${{ steps.tag.outputs.version }}
          gh release create ${{ steps.tag.outputs.version }} \
            --notes-file /tmp/release_notes.md \
            --title "${{ steps.tag.outputs.version }}"

      # GitHub APIë¡œ ë¨¸ì§€ëœ PRì˜ head branch ì¡°íšŒ (squash/rebase mergeì—ë„ ë™ì‘)
      - name: Delete release branch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          branch=""
          if api_response=$(gh api "/repos/${{ github.repository }}/commits/${{ github.sha }}/pulls" 2>/dev/null); then
            branch=$(echo "$api_response" | jq -r '.[0].head.ref // empty')
          fi

          # API ì‹¤íŒ¨ ë˜ëŠ” ê²°ê³¼ ì—†ì„ ì‹œ ì»¤ë°‹ ë©”ì‹œì§€ íŒŒì‹± fallback
          if [ -z "$branch" ]; then
            commit_msg=$(git log -1 --pretty=%s)
            branch=$(echo "$commit_msg" | grep -oE '(release-[0-9]+\.[0-9]+\.[0-9]+|hotfix/[^ "]+|hotfix)' | head -1)
          fi

          if [ -n "$branch" ]; then
            echo "Deleting merged branch: $branch"
            gh api -X DELETE "/repos/${{ github.repository }}/git/refs/heads/${branch}" \
              && echo "Deleted: $branch" \
              || echo "Branch not found or already deleted: $branch"
          else
            echo "No release/hotfix branch found for commit: ${{ github.sha }}"
          fi

      # release ë¸Œëœì¹˜ì— fix ì»¤ë°‹ì´ ìˆì„ ë•Œë§Œ back-merge PR ìƒì„±
      # (í´ë¦° ë¦´ë¦¬ì¦ˆëŠ” developì´ ì´ë¯¸ ìµœì‹  â†’ skip)
      - name: Back-merge main to develop
        if: ${{ inputs.back_merge_enabled }}
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          git fetch origin develop
          commits=$(git log origin/develop..origin/main --no-merges --oneline)
          if [ -z "$commits" ]; then
            echo "No back-merge needed (develop already has all commits)"
            exit 0
          fi

          echo "Back-merge needed. Commits not in develop:"
          echo "$commits"

          # PATìœ¼ë¡œ remote ì „í™˜ (GITHUB_TOKEN pushëŠ” workflow íŠ¸ë¦¬ê±° ì•ˆ ë¨ + Branch Protection ì œí•œ)
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git"

          back_branch="back-merge/${{ steps.tag.outputs.version }}"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git checkout -b "$back_branch" origin/develop

          if git merge origin/main --no-edit -m "chore: back-merge main into develop (${{ steps.tag.outputs.version }})"; then
            git push origin "$back_branch"
            {
              echo "## Back-merge: main â†’ develop"
              echo ""
              echo "ë¦´ë¦¬ì¦ˆ \`${{ steps.tag.outputs.version }}\` ì—ì„œ ì§ì ‘ ìˆ˜ì •ëœ ì»¤ë°‹ì„ developì— ì—­ë³‘í•©í•©ë‹ˆë‹¤."
              echo ""
              echo "### í¬í•¨ëœ ì»¤ë°‹"
              echo "$commits" | sed 's/^/- /'
              echo ""
              echo "---"
              echo "> \`ci-main\` ì›Œí¬í”Œë¡œìš°ì— ì˜í•´ ìë™ ìƒì„±"
            } > /tmp/pr_body.md
            pr_url=$(gh pr create \
              --base develop \
              --head "$back_branch" \
              --title "chore: back-merge main â†’ develop (${{ steps.tag.outputs.version }})" \
              --body-file /tmp/pr_body.md)
            echo "PR created: $pr_url"
            # branch protection ì„¤ì • ì‹œ --autoë¡œ CI í†µê³¼ í›„ ë¨¸ì§€
            # ë¯¸ì„¤ì • ì‹œ fallback: ì¦‰ì‹œ ë¨¸ì§€
            if ! gh pr merge "$back_branch" --auto --merge --delete-branch 2>/dev/null; then
              gh pr merge "$back_branch" --merge --delete-branch
              echo "Merged directly (no branch protection configured)"
            else
              echo "Auto-merge enabled: will merge when CI passes"
            fi
          else
            git merge --abort
            echo "::warning::Merge conflict detected. Please manually back-merge main into develop."
          fi
